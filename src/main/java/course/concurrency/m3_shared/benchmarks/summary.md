# Исследование производительности инструментов работы в многопоточной среде

## Наблюдения

### Общие

Fair локи на два порядка медленнее своих unfair аналогов.

`Semaphore` - немного медленнее `ReentrantLock` при любых сценариях использования.
А в сочетании с тем, что им еще и неудобно пользоваться, то он в целом не рекомендован к использованию.

`ReentrantLock` оказался на порядок быстрее `synchronized` по изменяемой переменной.
Это происходит благодаря тому, что ReentrantLock захватывает доступ с помощью CAS операции.

Самый производительный способ работы с переменной в многопоточке: пометить ее `volatile`, запись проводить с блокировкой, а чтение без.
Но делать так можно только с иммутабельными классами и примитивами и только в случае, если мы осознаем, что прочитанное значение становится устаревшим в то же мгновение, как мы его прочитали.


### По результатам WRITER = 7, READER = 1
`LongAdder` на порядок более производительный, чем `AtomicLong` при большом количестве вставок.

Синхронизация по `volatile` переменной работает почти на 2 порядка производительнее,
чем просто синхронизация.
Происходит так видимо потому, что при использовании `volatile` переменной не нужна синхронизация на чтение.
И из-за отсутствия синхронизации на чтение получаем профит.
Также можно наблюдать, что синхронизация по `volatile` переменной на порядок быстрее волательной переменной
без синхронизации, но это может быть вызвано тем, что в бенче на волатильную переменную без синхронизации используется
вызов `System.currentTimeMillis()`, который имеет собственные ограничения не throughput.


### По результатам WRITER = 4, READER = 4
При равномерной нагрузке на чтение и запись `AtomicLong` в несколько раз производительнее `LongAdder`.

`ReadWriteLock` работает в несколько раз хуже, чем `ReentrantLock`

`StampedLock` с оптимистической блокировкой на чтение на порядок производительнее других локов.
Если не требуется свойство reentrancy, то можно задуматься о использовании `StampedLock`.

Синхронизация по `volatile` переменной работает почти на 2 порядка производительнее,
чем просто синхронизация.
Происходит так видимо потому, что при исползовании `volatile` переменной не нужна синхронизация на чтение.
И из-за отсутствия синхронизации на чтение получаем профит.


### По результатам WRITER = 1, READER = 7
Странно, но `AtomicLong` в этом сценарии оказался ненамного лучше `LongAdder`.

`ReadWriteLock` работает в несколько раз хуже, чем `ReentrantLock`.

`StampedLock` с оптимистической блокировкой на чтение оказался немного лучше других локов.

Синхронизация по `volatile` переменной работает так же, как просто волатильная переменная.
Что неудивительно, т.к. их чтение производится одинаково.


---
## Рекомендации
- Иметь серьезные обоснования для использования fair локов
- Не использовать `Semaphore`, если его можно заменить чем-либо еще
- Использовать `ReentrantLock` вместо синхронизации
- Вместо `ReadWriteLock` использовать `ReentrantLock`
- `LongAdder` использовать только в сценарии с большим количеством вставок и когда нет необходимости в момент изменения знать текущее значение счетчика
- При большом количестве чтения инструменты, основанные на оптимистических блокировках, всегда оказывается более производительными
- Для максимальной производительности помечаем переменную `volatile`, запись проводим с блокировкой, а чтение без.
  Делать так можно только с иммутабельными классами и примитивами и только в случае, если мы осознаем, что прочитанное значение становится устаревшим в то же мгновение, как мы его прочитали




